--1. PL/SQL(Procedual Language Extension to SQL) : 오라클에서 제공하는 절차적 언어를 만들기 위한 기능 
--												쿼리문에 변수를 선언하고 조건문이나 반복문을 사용할 수 있다. 
--PL/SQL 에서는 결과를 출력하기 위해서 DBMS_OUTPUT.PUT_LINE 함수를 이용한다. 


--1-1.기본적인 PL/SQL 
DECLARE 
	--변수의 선언은 변수명 데이터타입
	--선언부에서 변수의 값을 할당해도 되고 안해도 된다.
	--선언부에서 변수의 값을 할당하지 않으면 실행부에서 변수의 값을 할당해도 된다.
	NUM NUMBER;
BEGIN 
	NUM := 10; 
	DBMS_OUTPUT.PUT_LINE(NUM);
END;

--1-2.예외처리가 포함된 PL/SQL

DECLARE 
	NUM1 NUMBER := 10; 
	NUM2 NUMBER := 0; 
BEGIN 
	DBMS_OUTPUT.PUT_LINE(NUM1/NUM2);
EXCEPTION 
	WHEN ZERO_DIVIDE THEN 
	DBMS_OUTPUT.PUT_LINE('0으로 나눌 수 없습니다.');
	DBMS_OUTPUT.PUT_LINE(NUM1 / 1);
END; 


--1-3. 참조형 변수 선언(테이블의 컬럼 타입 참조)
DECLARE 
	--STUDENT 테이블의 SNO 컬럼타입과 동일한 타입으로 지정된다. 
	STUDENT_NO STUDENT.SNO%TYPE;
	--STUDENT 테이블의 SNAME 컬럼의 타입과 동일한 타입으로 지정된다. 
	STUDENT_NAME STUDENT.SNAME%TYPE; 
BEGIN 
	STUDENT_NO := '1111111';
	STUDENT_NAME := '고기천';

	DBMS_OUTPUT.PUT_LINE(STUDENT_NO);
	DBMS_OUTPUT.PUT_LINE(STUDENT_NAME);
END;


--1-4.테이블의 행을 참조한 행 참조변수 선언 
DECLARE 
	--STUDENT 테이블에 존재하는 컬럼을 모두 가지고 있는 변수 선언 
	--STUDENT_ROW 변수에는 SNO, SNAME, SEX, SYEAR, MAJOR, AVR포함되어 있다. 
	STUDENT_ROW STUDENT%ROWTYPE;
BEGIN 
	--각각 컬럼의 데이터 타입은 참조한 테이블의 컬럼의 데이터 타입과 동일하다. 
	STUDENT_ROW.SNO := '222222';
	STUDENT_ROW.SNAME := '홍길동';
	STUDENT_ROW.SEX := '남';
	STUDENT_ROW.SYEAR := 1;
	STUDENT_ROW.MAJOR := '컴공';
	STUDENT_ROW.AVR := 3.56;
	
	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.SNO);
 	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.SNAME);
 	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.SEX);
 	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.SYEAR);
 	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.MAJOR);
 	DBMS_OUTPUT.PUT_LINE(STUDENT_ROW.AVR);
END;

--1-5. SELECT 구문을 이용한 변수의 값 할당
--SELECT 구문을 이용해서 변수 값을 할당할 떄는 BEGIN부 안에서 할당한다. 
DECLARE 
	STUDENT_NO STUDENT.SNO%TYPE;
BEGIN
	--SELECT INTO 구문 
	--SELECT 조회할 값 INTO 저장할 변수 
	--FROM 
	SELECT SNO INTO STUDENT_NO
		FROM STUDENT 
		WHERE SNAME = '고기천';
	
	


END;

--EMP 테이블의 컬럼을 모두 참조하는 변수를 선언하고 
--ENO이 0001인 사원의 데이터를 모두 출력하세요.

DECLARE
	 EMP_ROW EMP%ROWTYPE;
BEGIN 
	SELECT ENO, ENAME , JOB, MGR , HDATE, SAL, COMM, DNO  INTO EMP_ROW
		FROM EMP 
		WHERE ENO = '0001';
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.ENO);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.ENAME);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.JOB);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.MGR);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.HDATE);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.SAL);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.COMM);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.DNO);
END;

DECLARE
	 EMP_ROW EMP%ROWTYPE;
BEGIN 
	SELECT * INTO EMP_ROW
		FROM EMP 
		WHERE ENO = '0001';
DBMS_OUTPUT.PUT_LINE(EMP_ROW.ENO);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.ENAME);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.JOB);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.MGR);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.HDATE);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.SAL);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.COMM);
	DBMS_OUTPUT.PUT_LINE(EMP_ROW.DNO);
END;

--2. 조건문(IF/CASE)

--2-1.IF
/*
 * 
 * IF 조건 1 THEN 실행문1 
 * ELSIF 조건2 THEN 실행문2
 * ELSIF 조건3 THEN 실행문3
 * ...
 * ELSIF 조건N THEN 실행문N
 * ELSE실행문 
 * END IF;
 * 
 * 
 */
 
DECLARE 
	NUM1 NUMBER := 12345;
	NUM2 NUMBER := 113;
BEGIN
	IF MOD(NUM1, NUM2) = 0 THEN
		DBMS_OUTPUT.PUT_LINE(NUM2 || '는' || NUM1 || '의 약수입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE(NUM2 || '는' || NUM1 || '의 약수가 아닙니다.');
	END IF;
END;


DECLARE 
	DEPT_ROW DEPT%ROWTYPE; 
BEGIN 
	SELECT * INTO DEPT_ROW 
		FROM DEPT
		WHERE DNO = '30'; 
	IF DEPT_ROW.LOC = '서울' THEN 
		DBMS_OUTPUT.PUT_LINE(DEPT_ROW.DNAME || '부서의 지역은 서울입니다.' ) ;
	ELSIF DEPT_ROW.LOC ='대전' THEN
		DBMS_OUTPUT.PUT_LINE(DEPT_ROW.DNAME || '부서의 지역은 대전입니다.');
	ELSIF DEPT_ROW.LOC = '부산' THEN 
		DBMS_OUTPUT.PUT_LINE(DEPT_ROW.DNAME || '부서의 지역은 부산입니다.');
	ELSE 
		DBMS_OUTPUT.PUT_LINE(DEPT_ROW.DNAME || '부서의 지역은 서울, 대전, 부산 외의 지역입니다.');
	END IF;
END;


--PROFESSOR 테이블의 모든 컬럼을 참조하는 변수를 선언하고 
--교수가 정교수인지 부교수인지 출력하는 PL/SQL을 작성하세요. 
--정교수, 부교수가 아닌 교수는 시간강사입니다. 를 출력하세요. 
--PNO가 1032인 교수의 데이터 참조

DECLARE 
	PROFESSOR_ROW PROFESSOR%ROWTYPE;
BEGIN
	SELECT * INTO PROFESSOR_ROW
		FROM PROFESSOR
		WHERE PNO = 1032;
	IF PROFESSOR_ROW.ORDERS = '정교수' THEN 
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 정교수입니다.');
	ELSIF PROFESSOR_ROW.ORDERS = '부교수'  THEN
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 부교수입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 시간강사입니다.');
	END IF;
END;


--2-2. CASE 구문 


DECLARE 
	PROFESSOR_ROW PROFESSOR%ROWTYPE;
BEGIN
	SELECT * INTO PROFESSOR_ROW
		FROM PROFESSOR
		WHERE PNO = 1032;
	--CASE1: CASE 뒤에 변수를 지정해서 값으로만 조건비교 
	CASE PROFESSOR_ROW.ORDERS 
	WHEN '정교수' THEN 
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 정교수입니다.');
	CASE PROFESSOR_ROW.ORDERS 
	WHEN '부교수'  THEN
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 부교수입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 시간강사입니다.');
	END CASE;
END;

	--CASE2 : CASE 뒤에 변수를 지정하지 않고 WHEN 절에서 조건식으로 비교 
	CASE 
	WHEN PROFESSOR_ROW.ORDERS = '정교수' THEN 
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 정교수입니다.'); 
	WHEN PROFESSOR_ROW.ORDERS = '부교수' THEN
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 부교수입니다.');
	ELSE
		DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME || '은 시간강사입니다.');
	END CASE;


END;

--3.반복문(기본 LOOP, WHILE LOOP, FOR LOOP)
--3-1. 기본 LOOP
DECLARE 
	 NUM1 NUMBER := 1; 
BEGIN 
	LOOP
		NUM1 NUMBER + 1; 
		--특정 조건일 때 이번 실행을 건너 뜀 
		CONTINUE WHEN MOD(NUM1, 2) != 0;
		DBMS_OUTPUT.PUT_LINE(NUM1);
		--특정 조건일 때 LOOP종료
		EXIT WHEN NUM1 >= 10; 
	END LOOP;
END;

--3-2. WHILE LOOP
--특정조건이 충족되는 동안 계속 반복 실행 


	
	
	
	
	
	
	
	
	
	
	
	
	
	




















	




